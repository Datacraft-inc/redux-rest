{"name":"redux-rest","tagline":"Automatically create Flux action constants, action creators and Redux reducers for your REST API","body":"[![Build Status](https://travis-ci.org/Kvoti/redux-rest.svg?branch=master)](https://travis-ci.org/Kvoti/redux-rest)\r\n\r\n# redux-rest\r\n\r\n**NOTE this only works with soon-to-be-released redux 1.0.0-rc**\r\n\r\n**NOTE POST/PUT requests currently tied to Django Rest Framework's CSRF handling and response content**\r\n\r\nAutomatically create Flux action constants, action creators and Redux\r\nreducers for your REST API.\r\n\r\n## Install\r\n```\r\nnpm install redux-rest@0.0.1-alpha.4\r\n```\r\n\r\n## Example\r\n```js\r\nimport React from 'react';\r\nimport { connect, Provider } from 'react-redux';\r\nimport { createStore, combineReducers, applyMiddleware } from 'redux';\r\nimport Flux, { asyncDispatch } from 'redux-rest';\r\n\r\n// This is a super simple app that displays a list of users from an API and\r\n// lets you add new users. Until a success response is recevied from the API\r\n// endpoint new users are show as pending.\r\n\r\n// To create a store with redux for this app all you have to do is\r\n// describe your API endpoints as key value pairs where the key is an\r\n// identifier and the value is the URL of the endpoint.\r\nconst myAPI = {\r\n  users: '/api/users/'\r\n};\r\n\r\n// Then create a Flux instance. This automatically creates\r\n// action creators and reducers for each endpoint. No boilerplate!\r\nconst flux = new Flux(myAPI);\r\n\r\n// UserApp uses the flux object to fetch the users and create new ones\r\n// using the automatically created action creators.\r\nclass UserApp extends React.component {\r\n\r\n  componentDidMount() {\r\n    // Request the list of users when this component mounts\r\n    this.props.dispatch(flux.actionCreators.users.list());\r\n  }\r\n\r\n  render() {\r\n    let users = this.props.users;\r\n    let pendingUsers = users.filter(u => u.status === 'pending');\r\n    let currentUsers = users.filter(u => u.status !== 'pending');\r\n    return (\r\n      <div>\r\n        {pendingUsers.map(user => <p>Saving {user.username}...</p>)}\r\n        <ul>\r\n          {currentUsers.map(user => <li>{user.username}</li>)}\r\n        </ul>\r\n        <input ref=\"username\" placeholder=\"Enter username\"/>\r\n        <input type=\"submit\" value=\"Add user\" onClick={this._addUser}/>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  _addUser() {\r\n    let inputNode = React.findDOMNode(this.refs.username);\r\n    let val = inputNode.value;\r\n    this.props.dispatch(\r\n      flux.actionCreators.users.create(\r\n        {username: val}\r\n      )\r\n    );\r\n    inputNode.val = '';\r\n  }\r\n}\r\n\r\n// The flux object also has reducers to handle the standard REST actions\r\n// So we can configure redux and connect our UserApp to it.\r\nlet reducers = combineReducers(flux.reducers);\r\n\r\n// To integrate with redux we need a middleware layer so we can do\r\n// async requests to the API server.\r\n// (Vanilla redux requires actions to be plain objects but the flux.actionCreators\r\n// methods return functions which launch an async request *then* dispatch the\r\n// corresponding action object).\r\nlet createStoreWithMiddleware = applyMiddleware(\r\n  asyncDispatch\r\n)(createStore);\r\n\r\nlet store = createStoreWithMiddleware(reducers);\r\n\r\n// Which props do we want to inject, given the global state?\r\nfunction select(state) {\r\n  // Each endpoint has an _items and _collection reducer. Here we only need\r\n  // the user items so we only pull out users_items.\r\n  return {\r\n    users: state.users_items\r\n  };\r\n})\r\n\r\n// Wrap UserApp to inject dispatch and state into it\r\nUserApp = connect(select)(UserApp);\r\n\r\nexport default class App extends React.Component {\r\n  render() {\r\n    // To render UserApp we need to wrap it in redux's Provider.\r\n    return (\r\n      <Provider store={store}>\r\n        {() => <UserApp />}\r\n      </Provider>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n## What is the Flux object?\r\n\r\nThe Flux object encapsulates common patterns when dealing with REST APIs.\r\n\r\nWhen created with a description of your API you can call all the actions you'd\r\nexpect and there are reducers that automatically handle those actions, including\r\n'pending', 'success' and 'failure' states.\r\n\r\n```js\r\nimport Flux from 'redux-rest';\r\n\r\nconst myAPI = {\r\n    users: '/api/users/',\r\n}\t   \r\n\r\nconst flux = new Flux(myAPI);\r\n```\r\n\r\nThis creates a pair of reducers for each API endpoint; a _collection_\r\nreducer to handle actions at the collection level and and _item_\r\nreducer to handle actions on individual items.\r\n\r\n    TODO not sure about the item/collection stuff. Needs a rethink.\r\n\r\nCalling actions is as simple as\r\n\r\n```js \r\nflux.actionCreators.users.create(userData);\r\n```\r\n\r\n### Status of API requests\r\n\r\nEach action creator triggers an API request and immediately dispatches\r\nan action so the UI can reflect the change straight away. During the\r\nrequest the state change is marked as pending. For example, creating a\r\nnew object,\r\n\r\n```js\r\nflux.actionCreators.users.create({username: 'mark'});\r\n```\r\n\r\nwill add,\r\n\r\n```js\r\n{\r\n    username: 'mark',\r\n    status: 'pending'\r\n}\r\n```\r\n\r\nto the state.\r\n\r\n    TODO what if 'status' is already a field of user?\r\n\r\nOn completion of the request the status is updated to ```saved``` or\r\n```failed``` as appropriate. E.g.\r\n\r\n```js\r\n{\r\n    username: 'mark',\r\n    status: 'saved'\r\n}\r\n```\r\n\r\n### Available actions\r\n\r\nThe standard set of REST actions is available; ```list```,\r\n```retrieve```, ```create``` and ```update```.\r\n\r\n## TODO\r\n- add `delete` action\r\n- add a `revert` action to revert optimistic changes if API request\r\nfails.\r\n- support APIs with custom endpoints\r\n- integrate normalizr for flat object storage?\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}